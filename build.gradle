buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.guardsquare:proguard-gradle:7.5.0'
    }
}

plugins {
    id 'java-library'
    id 'maven-publish'
    id 'io.github.goooler.shadow' version '8.1.7'
    //id 'checkstyle' // TODO: This is a reminder for me to setup checkstyle.
}

import org.apache.tools.ant.filters.ReplaceTokens

// Reproducible builds! https://docs.gradle.org/4.9/userguide/working_with_files.html#sec:reproducible_archives
tasks.withType(AbstractArchiveTask).configureEach {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

apply plugin: 'java'

// TODO: This is a reminder for me to setup checkstyle.
/* apply plugin: 'checkstyle'

configurations {
    checkstyleConfig
}

def versions = [
    checkstyle: '6.2',
]

dependencies {
    checkstyleConfig ("com.puppycrawl.tools:checkstyle:${versions.checkstyle}") {
        transitive = false
    }
}

checkstyle {
    toolVersion = "${versions.checkstyle}"
    config = resources.text.fromArchiveEntry(configurations.checkstyleConfig, 'google_checks.xml')
} */

final def compiler = javaToolchains.compilerFor {
    languageVersion = JavaLanguageVersion.of(7)
}

// Tells Gradle to use the previously defined Java 7 compatible JDK.
java {
    sourceCompatibility = 1.5
    targetCompatibility = 1.5

    toolchain {
        compiler
    }
}

// Tells Gradle to always compile with the previously defined Java 7 compatible JDK.
tasks.withType(JavaCompile).configureEach {
    javaCompiler = compiler
    sourceCompatibility = 1.5
    targetCompatibility = 1.5
    // Tells Gradle to include more debug information in compiled .class files.
    options.debug = true
    options.debugOptions.debugLevel = 'source,lines,vars'
}

repositories {
    mavenCentral()
    maven {
        name = 'mojang'
        url = 'https://libraries.minecraft.net/'
    }
}

shadowJar {
    from 'LICENSE.md'

    dependencies {
        exclude(dependency("org.ow2.asm:asm-all:${project.asmVersion}"))
        exclude(dependency("net.minecraft:launchwrapper:${project.launchwrapperVersion}"))
        //exclude(dependency("net.sf.jopt-simple:jopt-simple:${project.joptSimpleVersion}"))
        exclude(dependency("org.lwjgl.lwjgl:lwjgl:${project.lwjglVersion}"))
    }

    minimize()

    // Hacky exclusions to minimise file size.
    exclude 'org/**/*.txt'
    exclude 'META-INF/maven/**/*.*'
    exclude 'templates/release-notes.vm'

    // Currently, this merges all licences from each library into one file, as well as the same for notices.
    // TODO: Come up with a better way to do this. Ideally I'd rename the file based on the library.
    append 'META-INF/LICENSE.txt'
    append 'META-INF/NOTICE.txt'

    // Relocate libraries to prevent them from leaking into the classpath for other applications
    relocate 'org.apache.commons.codec', 'com.zero.retrowrapper.shadow.commons-codec'
    relocate 'org.apache.commons.io', 'com.zero.retrowrapper.shadow.commons-io'
    relocate 'org.apache.commons.lang3', 'com.zero.retrowrapper.shadow.commons-lang3'
    relocate 'com.eclipsesource.json', 'com.zero.retrowrapper.shadow.minimal-json'

    archiveClassifier = 'debug'
}

version = project.version
def versionWithMetadata = version
def gitTag

task checkRelease {
    if (System.getenv('BUILD_RELEASE') != 'true') {
        version += '-SNAPSHOT'
        gitTag = 'git rev-parse --short HEAD'.execute().text.trim()
        versionWithMetadata = version + '+' + gitTag
        if (!System.getenv('CI')) {
            versionWithMetadata += '.local'
        }
    } else {
        gitTag = System.getenv('RELEASE_TAG')
    }
}

dependencies {
    // asm
    api "org.ow2.asm:asm-all:${project.asmVersion}"

    // launchwrapper + dependencies
    api("net.minecraft:launchwrapper:${project.launchwrapperVersion}") {
        transitive = false
    }

    // jopt
    //api "net.sf.jopt-simple:jopt-simple:${project.joptSimpleVersion}"

    // lwjgl
    api("org.lwjgl.lwjgl:lwjgl:${project.lwjglVersion}") {
        transitive = false
    }

    // commons-codec, for Base 64 decoding of skin strings
    implementation "commons-codec:commons-codec:${project.commonsCodecVersion}"

    // commons-io, for file access
    implementation "commons-io:commons-io:${project.commonsIOVersion}"

    // commons-lang, for OS utilities
    implementation "org.apache.commons:commons-lang3:${project.commonsLangVersion}"

    // minimal-json
    implementation "com.eclipsesource.minimal-json:minimal-json:${project.minimalJsonVersion}"
}

import groovy.json.JsonOutput
import groovy.json.JsonSlurper

processResources {
    inputs.property 'version', project.version // Redo this task when version value changes.
    inputs.property 'versionWithMetadata', versionWithMetadata
    inputs.property 'gitTag', gitTag
    filesMatching('com/zero/retrowrapper/retrowrapperVersion.txt') {
        // replace build variables
        expand 'version': versionWithMetadata, 'tag': gitTag
    }

    // Minify .json files in built .jar
    doLast {
        fileTree(dir: outputs.files.asPath, includes: [
            "**/*.json"
        ]).each { final File file ->
            file.text = JsonOutput.toJson(new JsonSlurper().parse(file))
        }
    }
}

// Ensures that the encoding of source files is set to UTF-8, see http://yodaconditions.net/blog/fix-for-java-file-encoding-problems-with-gradle.html
tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

configurations {
    //depsForProGuard.extendsFrom(implementation, api)
    depsForProGuard.extendsFrom(api)
}

// This task uses ProGuard to shrink the built .jar's file size and optimise the bytecode, mainly by removing unused shadowed dependencies.
tasks.register('proguard', proguard.gradle.ProGuardTask) {
    dependsOn(shadowJar)

    injars 'build/libs/' + rootProject.name + '-' + version + '-debug.jar'
    outjars 'build/libs/' + rootProject.name + '-' + version + '.jar'

    // Get the location of rt.jar from the provided toolchain.
    // Note to self: probably support building with not outdated versions of Java in the future.
    libraryjars compiler.get().metadata.installationPath.asFile.absolutePath + '/lib/rt.jar'
    // If rt.jar is not there, try looking inside a JRE folder instead.
    libraryjars compiler.get().metadata.installationPath.asFile.absolutePath + '/jre/lib/rt.jar'

    // Add relevant libraries to ProGuard's list of libraries to optimise against.
    libraryjars project.configurations.depsForProGuard

    // Run more optimisation passes on release
    if (System.getenv('BUILD_RELEASE') == 'true') {
        optimizationpasses 99
    }

    // The rest of the configs are in this file
    configuration 'guard.pro'
}

jar {
    manifest {
        attributes(
                'Main-Class': 'com.zero.retrowrapper.installer.Installer'
        )
    }
    enabled = false
    dependsOn(proguard)
}

// This task creates a .jar file containing the source code of this project.
tasks.register('sourcesJar', Jar) {
    archiveClassifier = 'sources'
    from sourceSets.main.allSource
    from 'LICENSE.md'
}

// This task creates a Java 6 - 8 compatible MultiMC instance with the current build of RetroWrapper.
// This instance is intended to have parity with the standard launcher.
tasks.register('createMultiMCInstance', Zip) {
    dependsOn(proguard)

    inputs.property 'rrVersion', project.version
    inputs.property 'versionWithMetadata', versionWithMetadata
    archiveFileName = rootProject.name + '-' + project.version + '-MultiMC.J6.zip'
    destinationDirectory = layout.buildDirectory.dir('libs')

    from('multimc') {
        exclude 'patches/RetroWrapper-J9.json'
        filesMatching(['mmc-pack.json', 'patches/RetroWrapper-J6.json']) {
            filter(ReplaceTokens, tokens: [rrVersion: project.version])
        }
        rename('RetroWrapper-J6.json', 'RetroWrapper.json')
    }

    from(proguard.outputs.files.singleFile) {
        into 'libraries/'
    }
}

// This task creates a Java 9+ compatible MultiMC instance with the current build of RetroWrapper.
// This instance uses newer libraries than the standard launcher so LaunchWrapper can run on Java 9+.
tasks.register('createJ9MultiMCInstance', Zip) {
    dependsOn(proguard)

    inputs.property 'rrVersion', project.version
    inputs.property 'versionWithMetadata', versionWithMetadata
    archiveFileName = rootProject.name + '-' + project.version + '-MultiMC.J9+.zip'
    destinationDirectory = layout.buildDirectory.dir('libs')

    from('multimc') {
        exclude 'patches/RetroWrapper-J6.json'
        filesMatching(['mmc-pack.json', 'patches/RetroWrapper-J9.json']) {
            filter(ReplaceTokens, tokens: [rrVersion: project.version])
        }
        rename('RetroWrapper-J9.json', 'RetroWrapper.json')
    }

    from(proguard.outputs.files.singleFile) {
        into 'libraries/'
    }
}

build.finalizedBy(createMultiMCInstance, createJ9MultiMCInstance)

artifacts {
    archives sourcesJar
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            // Shadowed .jar
            final publication ->
                project.shadow.component(publication)
                // Source code in a .jar
                artifact(sourcesJar) {
                    builtBy sourcesJar
                }
        }
    }
}
